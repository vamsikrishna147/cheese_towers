<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cheese Towers Deluxe</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">
    <style>
        :root {
            --cheese-yellow-light: #FFDC73;
            --cheese-yellow-dark: #F2A602;
            --background-cream: #FFF8E7;
            --text-color: #6B4F2D;
            --shadow-color: rgba(107, 79, 45, 0.2);
            --blue-sky: #A0D8EF;
            --blue-sky-dark: #7AB8D3;
        }

        /* --- General Setup --- */
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: var(--background-cream);
            font-family: 'Fredoka One', cursive;
        }

        /* --- Game Container --- */
        #game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            height: 100%;
            max-height: 800px;
            overflow: hidden;
            border-radius: 25px;
            box-shadow: 0 15px 30px var(--shadow-color), 0 10px 10px var(--shadow-color);
            transition: transform 0.1s ease-in-out;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, var(--blue-sky), var(--blue-sky-dark));
        }
        
        /* --- Screens & Overlays --- */
        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            transition: opacity 0.5s ease, transform 0.5s ease;
            backface-visibility: hidden;
        }
        
        .screen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.95);
        }

        /* --- Home Screen --- */
        #home-screen {
            background: linear-gradient(to bottom, var(--blue-sky), var(--blue-sky-dark));
            z-index: 10;
        }
        .home-title {
            font-size: 3.5rem;
            color: white;
            text-shadow: 0 4px 0 var(--text-color);
            -webkit-text-stroke: 2px var(--text-color);
            margin-bottom: 0.2em;
        }
        .home-subtitle {
            font-size: 1.2rem;
            color: var(--text-color);
            margin-bottom: 2em;
        }
        #home-screen .mouse {
            position: absolute;
            bottom: 10px;
            width: 100px;
            height: auto;
        }
        #home-screen .cheese-stack {
             position: absolute;
             bottom: -20px;
             right: 10px;
             width: 150px;
        }

        /* --- UI Elements --- */
        .button {
            background: linear-gradient(180deg, var(--cheese-yellow-light), var(--cheese-yellow-dark));
            color: var(--text-color);
            padding: 1em 2em;
            border-radius: 15px;
            text-decoration: none;
            font-size: 1.5rem;
            border: 3px solid #fff;
            border-bottom: 6px solid var(--text-color);
            cursor: pointer;
            transition: all 0.15s ease;
            text-shadow: 0 2px 2px rgba(255,255,255,0.4);
        }
        .button:hover { transform: translateY(-3px); border-bottom-width: 8px; }
        .button:active { transform: translateY(1px); border-bottom-width: 6px; }

        /* --- In-Game UI --- */
        #in-game-ui { z-index: 5; justify-content: flex-start; }
        #score-display {
            margin-top: 20px;
            font-size: 3.5rem;
            color: white;
            text-shadow: 0 3px 0 var(--text-color);
            -webkit-text-stroke: 2px var(--text-color);
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 15px;
            display: flex;
            gap: 10px;
        }
        .control-btn {
            width: 40px; height: 40px;
            background: rgba(255,255,255,0.8);
            border-radius: 50%;
            border: 3px solid white;
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 3px 5px var(--shadow-color);
        }
        .control-btn svg { width: 60%; height: 60%; fill: var(--text-color); }
        
        /* --- Pause & Game Over Screens --- */
        .dialog {
            background: rgba(255, 248, 231, 0.9);
            padding: 2em;
            border-radius: 20px;
            border: 5px solid white;
            box-shadow: 0 5px 15px var(--shadow-color);
            backdrop-filter: blur(5px);
            width: 80%;
        }
        .dialog h2 {
            font-size: 2.5rem; color: var(--text-color); margin: 0 0 0.5em 0;
            text-shadow: 0 2px 0 rgba(255,255,255,0.5);
        }
        .dialog .button { font-size: 1rem; padding: 0.8em 1.5em; }
        .dialog-buttons { display: flex; gap: 10px; justify-content: center; margin-top: 1.5em; }
        #final-score { font-size: 3rem; color: var(--cheese-yellow-dark); text-shadow: 0 2px 0 #fff; }

        /* --- Shake Animation --- */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
            20%, 40%, 60%, 80% { transform: translateX(8px); }
        }
        .shake { animation: shake 0.5s cubic-bezier(.36,.07,.19,.97); }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-container">
            <canvas id="gameCanvas"></canvas>

            <!-- Home Screen -->
            <div id="home-screen" class="screen">
                <h1 class="home-title">Cheese Towers</h1>
                <p class="home-subtitle">Stack 'em high, don't be shy!</p>
                <div class="button" id="play-button">Play</div>
                <!-- Decorative SVG Images -->
                <svg class="mouse" viewBox="0 0 100 80"><path d="M50 80 C 20 80, 20 50, 50 50 C 80 50, 80 80, 50 80 Z" fill="#D3D3D3"/><circle cx="35" cy="40" r="15" fill="#EAEAEA"/><circle cx="65" cy="40" r="15" fill="#EAEAEA"/><circle cx="45" cy="60" r="3" fill="black"/><circle cx="55" cy="60" r="3" fill="black"/><path d="M50 68 Q 52 72, 54 68" stroke="black" fill="none" stroke-width="2" stroke-linecap="round"/></svg>
                <svg class="cheese-stack" viewBox="0 0 150 120"><g transform="translate(0 30)"><rect x="10" y="50" width="130" height="30" rx="8" fill="#FFD700"/><circle cx="40" cy="65" r="5" fill="#F2A602"/><circle cx="90" cy="65" r="8" fill="#F2A602"/></g><g transform="translate(10 15)"><rect x="10" y="50" width="110" height="30" rx="8" fill="#FFA500"/><circle cx="30" cy="65" r="4" fill="#FFD700"/><circle cx="70" cy="65" r="6" fill="#FFD700"/></g><g transform="translate(20 0)"><rect x="10" y="50" width="90" height="30" rx="8" fill="#FFD700"/><circle cx="50" cy="65" r="7" fill="#F2A602"/></g></svg>
            </div>

            <!-- In-Game UI -->
            <div id="in-game-ui" class="screen hidden">
                <div id="score-display">0</div>
                <div id="controls">
                    <div id="pause-btn" class="control-btn"><svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg></div>
                    <div id="restart-btn-in-game" class="control-btn"><svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg></div>
                    <div id="exit-btn" class="control-btn"><svg viewBox="0 0 24 24"><path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"/></svg></div>
                </div>
            </div>

            <!-- Pause Screen -->
            <div id="pause-screen" class="screen hidden">
                <div class="dialog">
                    <h2>Paused</h2>
                    <div class="dialog-buttons">
                        <div id="resume-btn" class="button">Resume</div>
                    </div>
                </div>
            </div>
            
            <!-- Game Over Screen -->
            <div id="game-over-screen" class="screen hidden">
                <div class="dialog">
                    <h2>Game Over!</h2>
                    <p>Your cheesy tower had</p>
                    <div id="final-score">0</div>
                    <p>slices!</p>
                    <p class="high-score">High Score: <span id="high-score-display">0</span></p>
                    <div class="dialog-buttons">
                        <div id="restart-btn-game-over" class="button">Try Again</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gameContainer = document.getElementById('game-container');
const wrapper = document.getElementById('game-wrapper');

// Screens
const screens = {
    home: document.getElementById('home-screen'),
    game: document.getElementById('in-game-ui'),
    pause: document.getElementById('pause-screen'),
    gameOver: document.getElementById('game-over-screen')
};

// Buttons
const playBtn = document.getElementById('play-button');
const pauseBtn = document.getElementById('pause-btn');
const resumeBtn = document.getElementById('resume-btn');
const exitBtn = document.getElementById('exit-btn');
const restartBtnInGame = document.getElementById('restart-btn-in-game');
const restartBtnGameOver = document.getElementById('restart-btn-game-over');


// UI Displays
const scoreDisplay = document.getElementById('score-display');
const finalScoreDisplay = document.getElementById('final-score');
const highScoreDisplay = document.getElementById('high-score-display');

// --- Game Constants & State ---
let blockHeight, stack, fallingPieces, score, speed, gameState, animationFrameId, perfectStreak, cameraY, highScore;
const PERFECT_TOLERANCE = 5; // Easier to get a perfect stack
const GRAVITY = 0.2;
const HIGH_SCORE_KEY = 'cheeseTowersHighScore';

// --- Mouse Character ---
const mouse = {
    x: 0, y: 0, size: 60, emotion: 'happy', // happy, worried, sad
    draw() {
        const baseX = this.x;
        const baseY = this.y;
        
        ctx.save();
        ctx.translate(baseX, baseY);
        
        // Body
        ctx.fillStyle = '#C0C0C0';
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size * 0.5, this.size * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Ears
        ctx.fillStyle = '#E0E0E0';
        ctx.beginPath();
        ctx.arc(-this.size * 0.35, -this.size * 0.3, this.size * 0.25, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.size * 0.35, -this.size * 0.3, this.size * 0.25, 0, Math.PI * 2);
        ctx.fill();

        // Eyes
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(-this.size * 0.15, -this.size*0.05, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.size * 0.15, -this.size*0.05, 3, 0, Math.PI * 2);
        ctx.fill();

        // Mouth
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.beginPath();
        if (this.emotion === 'happy') {
            ctx.arc(0, this.size * 0.1, this.size * 0.15, 0, Math.PI);
        } else if (this.emotion === 'worried') {
            ctx.moveTo(-this.size * 0.15, this.size * 0.15);
            ctx.lineTo(this.size * 0.15, this.size * 0.15);
        } else { // sad
            ctx.arc(0, this.size * 0.2, this.size * 0.15, Math.PI, Math.PI*2);
        }
        ctx.stroke();

        ctx.restore();
    }
};

function switchScreen(screenName) {
    Object.keys(screens).forEach(key => {
        screens[key].classList.add('hidden');
    });
    if (screens[screenName]) {
        screens[screenName].classList.remove('hidden');
    }
}

function init() {
    resizeCanvas();
    stack = [];
    fallingPieces = [];
    score = 0;
    speed = 0.8; // Slower initial speed
    perfectStreak = 0;
    gameState = 'playing';
    cameraY = 0;

    scoreDisplay.textContent = '0';
    switchScreen('game');

    const dpr = window.devicePixelRatio || 1;
    const logicalCanvasHeight = canvas.height / dpr;
    const baseWidth = (canvas.width / dpr) * 0.7; // Wider base
    stack.push(createBlock(
        ((canvas.width / dpr) - baseWidth) / 2, 
        logicalCanvasHeight - blockHeight, 
        baseWidth, 'placed'
    ));
    
    addNewBlock();
    
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    gameLoop();
}

function createBlock(x, y, width, status) {
    const holes = [];
    for(let i = 0; i < 5; i++) {
        holes.push({
            x: Math.random(), y: Math.random(),
            r: Math.random() * (width / 20) + 2
        });
    }
    return {
        x, y, width, height: blockHeight, status,
        direction: 1,
        color1: '#FFD700', color2: '#FFA500',
        holes
    };
}

function addNewBlock() {
    const prev = stack[stack.length - 1];
    let newWidth = prev.width;
    // Reduce size over time to increase difficulty
    if (score > 10 && score % 2 === 0) { // Shrinking starts later
        newWidth = Math.max(prev.width * 0.99, (canvas.width / (window.devicePixelRatio || 1)) * 0.2); // Shrinks slower
    }
    // Start the new block at the left edge. Its y-pos is set in the game loop.
    const newBlock = createBlock(0, 0, newWidth, 'moving');
    stack.push(newBlock);
}

function placeBlock() {
    if (gameState !== 'playing') return;

    const current = stack[stack.length - 1];
    const prev = stack[stack.length - 2];
    
    // Set its final position in the stack
    current.y = prev.y - blockHeight;
    current.status = 'placed';
    current.isSettling = true;
    current.settleFrames = 15; // Total frames for the squash animation

    const overlap = Math.max(0, Math.min(current.x + current.width, prev.x + prev.width) - Math.max(current.x, prev.x));
    
    // Check for a perfect stack
    const diff = Math.abs(current.x - prev.x);
    if (diff < PERFECT_TOLERANCE) {
        perfectStreak++;
        current.x = prev.x; // Snap to perfect position
        current.width = prev.width; // Restore width
        if(perfectStreak > 2) {
            // Reward: increase size slightly
            current.width = Math.min(current.width * 1.05, (canvas.width / (window.devicePixelRatio || 1)) * 0.7);
        }
    } else {
        perfectStreak = 0;
    }

    if (overlap > 0) {
        mouse.emotion = 'happy';
        const cutOffWidth = current.width - overlap;
        if (cutOffWidth > 0) {
            fallingPieces.push({
                ...createBlock(
                    current.x < prev.x ? current.x : prev.x + prev.width,
                    current.y,
                    cutOffWidth, 'falling'
                ),
                vy: 1, vx: current.x < prev.x ? -1 : 1
            });
        }
        
        current.width = overlap;
        current.x = Math.max(current.x, prev.x);
        
        score++;
        scoreDisplay.textContent = score;
        speed += 0.02; // Slower speed increase

        addNewBlock();
    } else {
        gameOver();
    }
}

function gameOver() {
    gameState = 'ending'; // Use a new state for the toppling animation
    mouse.emotion = 'sad';
    gameContainer.classList.add('shake');

    const missedPiece = stack.pop(); // The piece that was just dropped and missed
    
    if(missedPiece) {
        missedPiece.y = stack.length > 0 ? stack[stack.length-1].y - blockHeight : (canvas.height / (window.devicePixelRatio || 1)) - blockHeight*2;
        const logicalCanvasWidth = canvas.width / (window.devicePixelRatio || 1);
        const fallDirection = (missedPiece.x + missedPiece.width / 2 < logicalCanvasWidth / 2) ? -1 : 1;
        fallingPieces.push({
            ...missedPiece, 
            status: 'falling',
            vy: 0, // Start with zero vertical velocity and let gravity take over.
            vx: fallDirection * 2
        });
    }

    // Make the rest of the tower topple
    stack.forEach(block => {
        fallingPieces.push({
            ...block,
            status: 'falling',
            vy: -2 + Math.random() * 2, // Pop up slightly
            vx: (Math.random() - 0.5) * 5 // Go sideways
        });
    });
    stack = []; // Clear the stack for the animation

    setTimeout(() => {
        gameContainer.classList.remove('shake');
        updateHighScore();
        finalScoreDisplay.textContent = score;
        highScoreDisplay.textContent = highScore;
        switchScreen('gameOver');
    }, 2000); // Wait for the animation to play out
}

function updateHighScore() {
    if (score > highScore) {
        highScore = score;
        localStorage.setItem(HIGH_SCORE_KEY, highScore);
    }
}


function pauseGame() {
    if (gameState !== 'playing') return;
    gameState = 'paused';
    switchScreen('pause');
}

function resumeGame() {
    if (gameState !== 'paused') return;
    gameState = 'playing';
    switchScreen('game');
    gameLoop();
}

function exitToHome() {
    if (animationFrameId) cancelAnimationFrame(animationFrameId);
    gameState = 'home';
    updateHighScore();
    switchScreen('home');
}

// --- Drawing ---
function drawBlock3D(block) {
    let { x, y, width, height, color1, color2, holes } = block;
    const sideHeight = height * 0.2;
    
    if (block.isSettling && block.settleFrames > 0) {
        const t = block.settleFrames / 15; // Animation progress (from 1 down to 0)
        // Use a sine wave to create a squash-and-rebound effect
        const squashRatio = Math.sin((1 - t) * Math.PI) * 0.1; // Max 10% squash

        const squashAmountY = height * squashRatio;
        const originalHeight = block.height;
        y += (originalHeight - (originalHeight - squashAmountY)) / 2;
        height = originalHeight - squashAmountY;
        
        const stretchAmountX = width * squashRatio;
        x -= stretchAmountX / 2;
        width += stretchAmountX;
    }

    // Side/bottom face (darker)
    ctx.fillStyle = color2;
    ctx.beginPath();
    ctx.moveTo(x, y + height);
    ctx.lineTo(x + sideHeight, y + height + sideHeight);
    ctx.lineTo(x + width + sideHeight, y + height + sideHeight);
    ctx.lineTo(x + width, y + height);
    ctx.closePath();
    ctx.fill();
    
    // Right face (darker)
    ctx.beginPath();
    ctx.moveTo(x + width, y);
    ctx.lineTo(x + width + sideHeight, y + sideHeight);
    ctx.lineTo(x + width + sideHeight, y + height + sideHeight);
    ctx.lineTo(x + width, y + height);
    ctx.closePath();
    ctx.fill();

    // Top face (lighter)
    ctx.fillStyle = color1;
    ctx.fillRect(x, y, width, height);

    // Cheese holes
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    holes.forEach(hole => {
        ctx.beginPath();
        ctx.arc(x + hole.x * width, y + hole.y * height, hole.r, 0, Math.PI * 2);
        ctx.fill();
    });
}

function gameLoop() {
    if (gameState === 'home' || gameState === 'paused' || gameState === 'ending') {
        if(gameState !== 'ending') {
            if(animationFrameId) cancelAnimationFrame(animationFrameId);
        }
    }

    if (gameState === 'ending') {
         // Continue drawing the falling pieces even when the game is over
    } else if (gameState !== 'playing') {
        return;
    }
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const dpr = window.devicePixelRatio || 1;
    const logicalCanvasWidth = canvas.width / dpr;
    const logicalCanvasHeight = canvas.height / dpr;

    // --- Update logic ---
    if (gameState === 'playing') {
        // Update moving block with sliding motion
        const current = stack[stack.length - 1];
        if (current.status === 'moving') {
            const prev = stack[stack.length - 2];
            
            // Set its Y position just above the stack
            current.y = prev.y - blockHeight;

            // Move it left and right
            current.x += current.direction * speed;

            // Wall collision
            if (current.x + current.width >= logicalCanvasWidth) {
                current.direction = -1;
                current.x = logicalCanvasWidth - current.width; // Clamp position
            } else if (current.x <= 0) {
                current.direction = 1;
                current.x = 0; // Clamp position
            }
            
            const distance = Math.abs((current.x + current.width / 2) - (prev.x + prev.width / 2));
            mouse.emotion = distance > prev.width / 1.5 ? 'worried' : 'happy';
        }

        // update settling blocks
        stack.forEach(b => {
            if (b.isSettling && b.settleFrames > 0) {
                b.settleFrames--;
            } else if (b.isSettling) { // End of animation
                b.isSettling = false;
            }
        });
    }

    // --- Camera & Drawing ---
    if (gameState !== 'ending') {
        const towerHeight = (stack.length > 1 ? (stack.length - 1) : 1) * blockHeight;
        const targetCameraY = towerHeight > logicalCanvasHeight * 0.6 ? towerHeight - logicalCanvasHeight * 0.6 : 0;
        cameraY += (targetCameraY - cameraY) * 0.1; 
    }

    ctx.save();
    ctx.translate(0, -cameraY);
    
    mouse.x = logicalCanvasWidth / 2;
    mouse.y = logicalCanvasHeight - mouse.size * 0.4;
    mouse.draw();

    stack.forEach(b => drawBlock3D(b));
    fallingPieces.forEach((p, index) => {
        p.y += p.vy;
        p.x += p.vx;
        p.vy += GRAVITY;
        drawBlock3D(p);
        if (p.y > logicalCanvasHeight + cameraY + 100) { // Give extra room before removing
            fallingPieces.splice(index, 1);
        }
    });
    
    ctx.restore();

    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Setup & Event Listeners ---
function resizeCanvas() {
    const container = document.getElementById('game-container');
    const dpr = window.devicePixelRatio || 1;
    const rect = container.getBoundingClientRect();
    
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    
    canvas.style.width = `${rect.width}px`;
    canvas.style.height = `${rect.height}px`;
    
    ctx.scale(dpr, dpr);

    blockHeight = (canvas.height / dpr) / 28;
}

playBtn.addEventListener('click', init);
pauseBtn.addEventListener('click', pauseGame);
resumeBtn.addEventListener('click', resumeGame);
exitBtn.addEventListener('click', exitToHome);
restartBtnInGame.addEventListener('click', init);
restartBtnGameOver.addEventListener('click', init);

document.addEventListener('click', (e) => {
    // Only handle clicks for placing blocks, not for UI buttons
    if (e.target.closest('.control-btn') || e.target.closest('.button')) return;
    if (gameState === 'playing') placeBlock();
});

// Initial Setup
function loadHighScore() {
    highScore = parseInt(localStorage.getItem(HIGH_SCORE_KEY)) || 0;
}

window.addEventListener('resize', resizeCanvas);
switchScreen('home');
resizeCanvas();
loadHighScore();

</script>
</body>
</html>

